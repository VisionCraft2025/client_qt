<?xml version="1.0" encoding="UTF-8"?>
<mcp_pipeline_improvement_request>
<context>
<project_overview>
Qt C++ 기반 스마트 팩토리 MCP (Model Context Protocol) Agent 시스템입니다.
현재 Gemini 2.5 Flash 모델을 사용하여 자연어 입력을 파싱하고 적절한 도구를 선택/실행하는 파이프라인을 구현했습니다.
</project_overview>

<current_architecture>
실제 구현된 아키텍처 (분석 결과):

1. 사용자 입력 → 특별 케이스 체크 (handleSpecialCases)
   - 🤖 기능 소개: "어떤 기능", "뭘 할 수 있" 등 → 미리 정의된 긴 응답 반환 (Gemini 호출 없음)
   - 🔧 장비 제어: "켜", "꺼" + 장비명 → 미리 정의된 도구 선택 (Gemini 호출 없음)  
   - 📊 데이터 조회: "정보", "데이터", "로그" 등 → db_find로 미리 결정 (Gemini 호출 없음)

2. 특별 케이스가 아닌 경우만 → Gemini API 호출 (도구 발견)
   - generatePromptForToolDiscovery() → sendGeminiRequest(TOOL_DISCOVERY)
   - handleGeminiReply() → parseToolDiscoveryResponse()

3. 도구 선택 완료 후 → 자동 연결 없음 (핵심 문제점)
   - toolDiscoveryCompleted 시그널 발생
   - 수동으로 pipelineToolExecution() 호출 필요

4. 도구 실행 단계 → Gemini API 재호출 (매개변수 생성)
   - generatePromptForToolExecution() → sendGeminiRequest(TOOL_EXECUTION)  
   - 매개변수 JSON 파싱 → executeToolRequest()

5. MCP 서버 도구 실행 → 결과 포맷팅 → 사용자 출력 → 컨텍스트 저장
</current_architecture>

<performance_issues>
성능 저하 요인 - 과도한 미리 정의된 응답:

1. 기능 소개 응답: 27줄의 하드코딩된 긴 텍스트
   ```
   응답: 🤖 **MCP 스마트 팩토리 시스템**
   제가 다음과 같은 작업들을 즉시 수행할 수 있습니다:
   ... [27줄의 고정 텍스트]
   어떤 작업부터 시작해드릴까요?
   ```

2. 장비 제어 미리 결정: 키워드 매칭으로 도구를 미리 선택
   - "피더1" → mqtt_device_control (하드코딩)
   - "컨베이어2/3, 로봇" → mqtt_device_control (하드코딩)
   - 나머지 → device_control (하드코딩)

3. 데이터 조회 미리 결정: 모든 데이터 관련 키워드 → db_find (하드코딩)

문제점:
- Gemini의 지능적 분석 능력을 활용하지 못함
- 새로운 패턴이나 복잡한 요청 처리 불가
- 확장성 제한 (새 장비/도구 추가 시 하드코딩 수정 필요)

파이프라인 연결 끊김의 실제 원인:
```cpp
// handleGeminiReply()에서 도구 발견 완료 후
emit toolDiscoveryCompleted(*m_currentContext);  // 시그널만 발생
// ❌ 자동으로 pipelineToolExecution() 호출되지 않음

// pipelineToolExecution()은 별도 호출 필요:
if (!context->selectedTool.has_value()) {
    pipelineToolDiscovery(userQuery);  // 다시 도구 발견으로 돌아감
    return;
}
```
</performance_issues>

<core_problem>
주요 문제점:
1. 파이프라인 자동 연결 실패: 도구 발견 후 도구 실행으로 자동 진행되지 않음
2. 과도한 하드코딩: Gemini 지능 활용 못하고 키워드 매칭에 의존
3. 비일관적 처리: 특별 케이스 vs 일반 케이스 처리 방식이 다름
4. 확장성 제한: 새로운 패턴 추가 시 코드 수정 필요
5. 성능 비효율: 불필요한 특별 케이스 체크로 인한 복잡성 증가
</core_problem>

<technical_details>
파이프라인 타입:
1. TOOL_DISCOVERY: 사용자 쿼리 분석 → 적절한 도구 선택
2. TOOL_EXECUTION: 선택된 도구 → 매개변수 생성 → 실제 실행

주요 클래스:
- MCPAgentClient: 메인 파이프라인 관리자
- ConversationContext: 대화 상태 및 컨텍스트 저장  
- PromptGenerators: Gemini용 프롬프트 생성 + handleSpecialCases (문제 지점)
- DataFormatter: 실행 결과 포맷팅

사용 가능한 도구:
8개 MCP 도구: db_find, db_count, db_aggregate, db_info, device_control, mqtt_device_control, conveyor_failure_stats, device_statistics

MQTT 기기 제어 토픽 정보 (home.cpp에서 확인됨):
```cpp
// controlALLDevices() 함수에서 사용되는 토픽들
m_client->publish(QMqttTopicName("feeder_02/cmd"), command.toUtf8());           // 피더2
m_client->publish(QMqttTopicName("conveyor_03/cmd"), command.toUtf8());         // 컨베이어3  
m_client->publish(QMqttTopicName("factory/conveyor_02/cmd"), command.toUtf8()); // 컨베이어2
m_client->publish(QMqttTopicName("robot_arm_01/cmd"), command.toUtf8());        // 로봇팔
// command: "on" 또는 "off"
```

제어 가능 기기:
- 피더2: feeder_02/cmd
- 컨베이어2: factory/conveyor_02/cmd  
- 컨베이어3: conveyor_03/cmd
- 로봇팔: robot_arm_01/cmd

제어 불가 기기 (로그 조회만):
- 컨베이어1, 피더1

시스템이 정확히 구현해야 하는 기능:
1. 기능 소개 (예: "어떤거 할 수 있어?")
   - 시스템 전체 기능을 사용자 친화적으로 소개

2. 날짜별 DB 로그 제공 (예: "컨베이어1 6월 정보 보여줘")
   - 원본 데이터가 아닌 파싱된 주요 내용만 표시
   - 날짜, 로그코드(에러/정상), 기기별 분류
   - 포맷: "📅 7월 28일 로그 / 12시 2분 | 🔴 SPD 에러 - 컨베이어1 속도 이상"

3. 기기별 실시간 로그 제공 (예: "컨베이어1 오늘 정보 보여줘")
   - 현재 날짜: 2025-07-28 자동 반영

4. 기기별 제어 (예: "피더2 켜줘" / "꺼줘")
   - MQTT를 통한 실시간 제어
   - 제어 가능 기기만 대상

5. 통계 제공 (예: "이번달 속도 에러(SPD) 통계 보여줘")
   - 로그 데이터 기반 통계 분석
</technical_details>
</context>

<desired_improvements>
<primary_goal>
1. 완전 자동화된 파이프라인: 사용자 한 번의 입력으로 도구 발견 → 도구 실행 → 결과 출력까지 자동 연결
2. Gemini 지능 활용 극대화: 하드코딩된 특별 케이스 제거, 모든 요청을 Gemini가 분석하도록 개선
3. 일관된 처리 방식: 모든 사용자 입력을 동일한 파이프라인으로 처리
4. MQTT 제어 정확성: home.cpp의 실제 토픽 구조 반영
</primary_goal>

<specific_requirements>
1. 자동 파이프라인 연결: 도구 발견 완료 시 자동으로 도구 실행 단계로 진행
2. 특별 케이스 처리 개선: handleSpecialCases() 로직을 Gemini 프롬프트로 통합
3. 상태 관리 개선: 각 파이프라인 단계별 상태 추적 및 오류 복구  
4. 비동기 흐름 제어: Qt signal-slot 기반 비동기 처리에서 순차적 파이프라인 보장
5. 컨텍스트 지속성: 파이프라인 전 과정에서 대화 컨텍스트 유지
6. 성능 최적화: 불필요한 키워드 체크 제거, Gemini 호출 효율화
7. 로그 데이터 파싱: 원본이 아닌 사용자 친화적 포맷으로 출력
</specific_requirements>
</desired_improvements>

<code_analysis_hints>
<problematic_areas>
1. PromptGenerators::handleSpecialCases(): 600여 줄의 하드코딩된 특별 케이스 처리
2. MCPAgentClient::handleGeminiReply(): 파이프라인 타입에 따른 후속 처리 로직에서 자동 연결 부재
3. signal-slot 연결: toolDiscoveryCompleted 시그널 후 자동 실행 메커니즘 부재
4. 비동기 상태 관리: 여러 비동기 호출 간 상태 동기화 미흡
</problematic_areas>

<successful_patterns>
1. ConversationContext를 통한 대화 상태 관리
2. DataFormatter의 결과 포맷팅 (특히 DB 데이터)
3. 도구 캐싱 메커니즘 (m_toolsCache)
4. 한글-영문 장비명 매핑 시스템
5. 로딩 애니메이션 및 사용자 피드백
6. MQTT 토픽 구조 (home.cpp 참조)
</successful_patterns>
</code_analysis_hints>

<expected_output>
<code_improvements>
1. handleSpecialCases() 완전 제거: 모든 처리를 Gemini로 통합
2. 자동 파이프라인 체이닝: 도구 발견 → 도구 실행 자동 연결
3. 통합 프롬프트 설계: 기능 소개/제어/조회를 하나의 지능적 프롬프트로 처리
4. 상태 머신 구현: 파이프라인 단계별 자동 전환 로직
5. 성능 최적화: 불필요한 키워드 체크 제거, API 호출 최적화
6. MQTT 제어 정확성: 실제 토픽 구조 반영한 제어 로직
7. 로그 파싱 로직: DB 원본을 사용자 친화적 형태로 변환
</code_improvements>

<architectural_suggestions>
개선된 아키텍처 패턴, 상태 관리 방식, 비동기 처리 최적화 방안을 제안해주세요.
특히 하드코딩된 특별 케이스들을 Gemini의 지능적 분석으로 대체하는 방법과,
Qt의 signal-slot을 효과적으로 활용하면서도 순차적 파이프라인을 보장하는 방법을 중점적으로 다뤄주세요.

구체적인 코드 수정 요청:
- MCPAgentClient.h/cpp 개선안
- PromptGenerators.cpp의 handleSpecialCases() 대체 방안
- 자동 파이프라인 연결을 위한 새로운 메서드 구현
- 통합 프롬프트 설계 및 응답 처리 로직

실제 작동하는 C++ 코드를 제공해주세요.
</architectural_suggestions>
</expected_output>

<additional_context>
- 프로젝트는 실제 스마트 팩토리 환경에서 사용될 예정
- 사용자는 주로 한국어로 자연어 명령을 입력
- 실시간성이 중요 (장비 제어, 실시간 모니터링)
- 코드 유지보수성과 확장성도 고려 필요
- 새로운 장비나 패턴 추가 시 코드 수정 없이 Gemini 프롬프트만으로 대응 가능해야 함
- 현재 날짜는 2025년 7월 28일이며, "오늘" 관련 쿼리 시 자동 반영 필요
</additional_context>
</mcp_pipeline_improvement_request>
